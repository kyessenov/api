// Code generated by protoc-gen-go.
// source: proxy/v1/config/egress_rule.proto
// DO NOT EDIT!

package istio_proxy_v1_config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Egress rules specify which domains outside of the mesh are allowed to be accessed by
// the microservices of the mesh. Currently, only two protocols are supported:
// HTTP and HTTPS. For HTTPS, the applications in the mesh will send HTTP requests to the
// appropriate port, e.g. GET http:/gmail.com:443. The Egress or the sidecar proxy will
// perform TLS origination.
//
// An example rule - allow traffic to *cnn.com and *cnn.it domains that are not part of the mesh.
//
// type: egress-rule
// spec:
//   name: cnn
//   domains:
//     - "*cnn.com"
//     - "*cnn.it"
//   ports:
//     - port: 80
//       protocol: http
//     - port: 443
//       protocol: https
//   use_egress_proxy: true
//
type EgressRule struct {
	// REQUIRED: Egress rules have unique names, e.g. "my-egress-rule".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// REQUIRED: list of domains to redirect outside of the mesh.
	// The domains are according to the definion of Envoy's domain of virtual hosts:
	// Wildcard hosts are supported in the form of “*.foo.com” or “*-bar.foo.com”.
	// Note that the wildcard will not match the empty string. e.g. “*-bar.foo.com” will match “baz-bar.foo.com”
	// but not “-bar.foo.com”.  Additionally, a special entry “*” is allowed which will match any host/authority header.
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// REQUIRED: list of ports on which the external services are available.
	Ports []*EgressRule_Port `protobuf:"bytes,3,rep,name=ports" json:"ports,omitempty"`
	// Forward all the external traffic through a dedicated egress proxy. It is used in some scenarios
	// where there is a requirement that all the external traffic goes through special dedicated nodes/pods.
	// These dedicated egress nodes could then be more closely monitored for security vulnerabilities.
	//
	// The default is false, i.e. the sidecar forwards external traffic directly to the external service.
	UseEgressProxy bool `protobuf:"varint,4,opt,name=use_egress_proxy,json=useEgressProxy" json:"use_egress_proxy,omitempty"`
}

func (m *EgressRule) Reset()                    { *m = EgressRule{} }
func (m *EgressRule) String() string            { return proto.CompactTextString(m) }
func (*EgressRule) ProtoMessage()               {}
func (*EgressRule) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *EgressRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EgressRule) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *EgressRule) GetPorts() []*EgressRule_Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *EgressRule) GetUseEgressProxy() bool {
	if m != nil {
		return m.UseEgressProxy
	}
	return false
}

// This message defines a port on which the external services are available.
// It is comprised of a port number and a protocol to communicate with the
// external services through that port number.
type EgressRule_Port struct {
	// The number of the port on which the external services are available.
	Port int32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
	// The protocol to communicate with the external services.
	// Currently supported HTTP and HTTPS
	Protocol string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
}

func (m *EgressRule_Port) Reset()                    { *m = EgressRule_Port{} }
func (m *EgressRule_Port) String() string            { return proto.CompactTextString(m) }
func (*EgressRule_Port) ProtoMessage()               {}
func (*EgressRule_Port) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

func (m *EgressRule_Port) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *EgressRule_Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func init() {
	proto.RegisterType((*EgressRule)(nil), "istio.proxy.v1.config.EgressRule")
	proto.RegisterType((*EgressRule_Port)(nil), "istio.proxy.v1.config.EgressRule.Port")
}

func init() { proto.RegisterFile("proxy/v1/config/egress_rule.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 216 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x8f, 0xcd, 0x4a, 0xc4, 0x30,
	0x14, 0x85, 0xc9, 0xb4, 0xa3, 0x33, 0x57, 0x10, 0x09, 0x08, 0x61, 0x56, 0xd1, 0x85, 0x64, 0x95,
	0x52, 0x05, 0x57, 0x6e, 0xdd, 0x97, 0xbc, 0x40, 0xa9, 0x35, 0x96, 0x40, 0xdb, 0x5b, 0xf2, 0x53,
	0xf4, 0x55, 0x7d, 0x1a, 0xc9, 0xad, 0x3f, 0x1b, 0x77, 0xe7, 0x84, 0xf3, 0x25, 0x5f, 0xe0, 0x66,
	0xf1, 0xf8, 0xfe, 0x51, 0xad, 0x75, 0xd5, 0xe3, 0xfc, 0xe6, 0x86, 0xca, 0x0e, 0xde, 0x86, 0xd0,
	0xfa, 0x34, 0x5a, 0xbd, 0x78, 0x8c, 0xc8, 0xaf, 0x5d, 0x88, 0x0e, 0x35, 0x0d, 0xf5, 0x5a, 0xeb,
	0x6d, 0x78, 0xfb, 0xc9, 0x00, 0x9e, 0x69, 0x6c, 0xd2, 0x68, 0x39, 0x87, 0x72, 0xee, 0x26, 0x2b,
	0x98, 0x64, 0xea, 0x68, 0x28, 0x73, 0x01, 0xe7, 0xaf, 0x38, 0x75, 0x6e, 0x0e, 0x62, 0x27, 0x0b,
	0x75, 0x34, 0x3f, 0x95, 0x3f, 0xc1, 0x7e, 0x41, 0x1f, 0x83, 0x28, 0x64, 0xa1, 0x2e, 0xee, 0xef,
	0xf4, 0xbf, 0x6f, 0xe8, 0xbf, 0xfb, 0x75, 0x83, 0x3e, 0x9a, 0x0d, 0xe2, 0x0a, 0xae, 0x52, 0xb0,
	0xed, 0xb7, 0x2a, 0x41, 0xa2, 0x94, 0x4c, 0x1d, 0xcc, 0x65, 0x0a, 0x76, 0x83, 0x9a, 0x7c, 0x7a,
	0x7a, 0x84, 0x32, 0x83, 0xd9, 0x2e, 0xa3, 0x64, 0xb7, 0x37, 0x94, 0xf9, 0x09, 0x0e, 0xf4, 0xc1,
	0x1e, 0x47, 0xb1, 0x23, 0xeb, 0xdf, 0xfe, 0x72, 0x46, 0xe9, 0xe1, 0x2b, 0x00, 0x00, 0xff, 0xff,
	0x86, 0x52, 0xe5, 0x5b, 0x1f, 0x01, 0x00, 0x00,
}
